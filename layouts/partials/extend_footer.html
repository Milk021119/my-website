<!-- 1. 气泡背景 Canvas -->
<canvas id="bubble-canvas" style="position:fixed;top:0;left:0;z-index:-1;width:100%;height:100%;pointer-events:none;"></canvas>

<!-- 2. 鼠标特效 HTML 元素 -->
<div id="cursor-dot"></div>
<div id="cursor-ring"></div>

<style>
    /* 气泡背景就不改了，直接修复鼠标样式 */
    #cursor-dot, #cursor-ring {
        position: fixed;
        top: 0;      /* 必须加上这一行，确定起始位置 */
        left: 0;     /* 必须加上这一行，确定起始位置 */
        pointer-events: none;
        border-radius: 50%;
        z-index: 9999;
        opacity: 0;  /* 初始隐藏，动鼠标才显示 */
        transition: opacity 0.3s;
    }
    #cursor-dot {
        width: 8px;
        height: 8px;
        background: #adadff;
    }
    #cursor-ring {
        width: 30px;
        height: 30px;
        border: 2px solid #adadff;
        /* 让圆环动起来更丝滑一点，增加一个 transition */
        transition: transform 0.15s ease-out, opacity 0.3s;
    }
</style>

<script>
/* ---------------- 效果 A: 气泡背景脚本 ---------------- */
(function() {
    const canvas = document.getElementById('bubble-canvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    let width, height, bubbles;
    function init() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        bubbles = [];
        for (let i = 0; i < 40; i++) { bubbles.push(new Bubble()); }
    }
    function Bubble() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.radius = Math.random() * 3 + 1;
        this.opacity = Math.random() * 0.5;
        this.velX = Math.random() * 0.5 - 0.25;
        this.velY = Math.random() * 0.5 - 0.25;
    }
    Bubble.prototype.draw = function() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(173, 216, 230, ${this.opacity})`;
        ctx.fill();
    };
    Bubble.prototype.update = function() {
        this.x += this.velX;
        this.y += this.velY;
        if (this.x < 0 || this.x > width) this.velX *= -1;
        if (this.y < 0 || this.y > height) this.velY *= -1;
    };
    function animate() {
        ctx.clearRect(0, 0, width, height);
        bubbles.forEach(bubble => { bubble.update(); bubble.draw(); });
        requestAnimationFrame(animate);
    }
    window.addEventListener('resize', init);
    init();
    animate();
})();

/* ---------------- 效果 B: 鼠标跟随脚本 ---------------- */
(function() {
    const dot = document.getElementById('cursor-dot');
    const ring = document.getElementById('cursor-ring');
    
    if(!dot || !ring) return;

    document.addEventListener('mousemove', (e) => {
        // 使用 requestAnimationFrame 能让动画在高性能显示器上不掉帧
        requestAnimationFrame(() => {
            const x = e.clientX;
            const y = e.clientY;
            
            dot.style.transform = `translate(${x - 4}px, ${y - 4}px)`;
            ring.style.transform = `translate(${x - 15}px, ${y - 15}px)`;
            
            dot.style.opacity = "1";
            ring.style.opacity = "1";
        });
    });
})();
</script>